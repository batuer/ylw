title:  ExecutorService和Executors
date: 2018年3月15日08:41:37
categories: Executors
tags: 

	 - 线程
	 - Executors
cover_picture: /images/Executor.jpg
---

### 1.  newFixedThreadPool

- 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。
- 该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。
- newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。
- 其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子 。
- 和cacheThreadPool不同，FixedThreadPool没有IDLE机制，所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器 。
- 从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同。
- fixed池线程数固定，并且是0秒IDLE（无IDLE），cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE。
- **重用**：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。
- **固定数目：**其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。
- **超时：**和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）
- **使用场景：**所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。
- **源码分析：**从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同：
  - fixed池线程数固定，并且是0秒IDLE（无IDLE）。
  - cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE。

### 2.  newCachedThreadPool

- 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。
- 该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。 
- 缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中 。
- 缓存型池子通常用于执行一些生存期很短的异步型任务。
- 能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。
- 注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。
- **重用：**缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。
- **使用场景：**缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。
- **超时：**能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。
- **结束：**注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。

### 3.  newSingleThreadExecutor

- 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。
- 该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。
- 单例线程，任意时间池中只能有一个线程 。
- 用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）。
- SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成。
- 如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。

### 4. newScheduledThreadPool

- 调度型线程池，这个池子里的线程可以按schedule依次delay执行，或周期执行。
- 该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。
- ScheduledThreadPool是一个固定大小的线程池，与FixedThreadPool类似，执行的任务是定时执行。

### 5.  Android性能优化之使用线程池处理异步任务

- 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失。
- 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM。
- 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿。

### 6.  使用线程池管理线程的优点

- ExecutorService是一个接口，线程池服务。
- hreadPoolExecutor实现ExecutorService接口封装了一系列API是的它具有线程池的特性，包括工作队列，核心线程池数，最大线程池数。
- 管理线程，节省内存资源，减小消耗。

### 7.  shutdown()和shutdownNow()的区别

- shutdown()方法在终止前允许执行以前提交的任务。不再接受新的任务。
- shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。